\chapter{О предмете этой книги}
\section{Классификация платформ по Таненбауму}

В своей книге "Архитектура компьютера" Таненбаум предложил иерархическое описание компьютерных платформ.\footnote{Эндрю Таненбаум (Andrew Tanenbaum) -- профессор  Амстердамского Свободного Университета, известный как "дедушка Линукса", а также как автор ряда учебников по организации вычислительных систем,  в том числе книги "Structured Computer Organisation" (в русском переводе -- "Архитектура компьютера").  В этой книге мы представляем несколько упрощенную версию предложенной Таненбаумом классификации, но надеемся, что она соответствует намерениям оригинала.}.  
В соответствии с этим описанием, ресурсы, предоставляемые платформой могут использоваться для решения определенного множества проблем или для поддержки других (более высокоуровневых) платформ.  Мир вычислений по сути своей иерархичен.  Это в равной степени относится и к анализу проблем, и к дизайну машин для решения этих проблем.  Вам полезно было бы ценить иерархии везде, где вы их находите.  Они полезны как познавательный инструмент, но, кроме того, они позволяют вам скрывать сложность под покрывалом абстракции.  По мере того, как мы будем двигаться вверх по иерархии платформ, мы будем иметь дело с предметами, все менее и менее зависимыми от определенной аппаратной реализации, и более доступными пониманию человека.

Предложенная Таненбаумом классификация платформ имеет нумерованные уровни, у которы больший номер означает, что платформа предлагает более высокий уровень абстракции и пользуется средствами, которые предоставляются платформами более низкого уровня.  Внизу (Уровень 0) мы находим аппаратные устройства, каждое из которых решает настолько крошечную задачу, что для достижения чего-то значимого нам необходимы тысячи или даже миллионы таких устройств.  Но без этих устройств ничто не будет работать.  Вверху (на Уровне 5 и выше) мы находим виртуальные машины выполняющие определенные прикладные задачи.  Удобно визуализировать иерархию Таненбаума в виде диаграммы и разместить представляющие интерес платформы на одном рисунке. (см. рис. \ref{levels}).
\begin{figure}
\caption{Иерархия платформ}\label{levels}
\end{figure}

Замечание: В последние десятилетия все чаще приходится сталкиваться с ситуацией, когда некоторые платформы высоких уровней заняты не решением прикладных задач или предоставлением высокоуровневых абстракций, а имитацией поведения платформ более низкого уровня.  Так, платформа Уровня 0 CdM-8 -- это не транзисторы и провода из кремния и меди, а виртуальные вентили и соединения, предоставляемые платформой уровня 5  -- программным эмулятором {\tt logisim}.  

Еще один пример -- это виртуальные машины в общепринятом современном смысле, например, те, которые создаются платформой VirtualBox или qemu.  Платформа VirtualBox (так называемый \emph{гипервизор}) -- это программный комплекс Уровня 5, который, используя ряд остроумных трюков и специализированных сервисов платформы Уровня 2, имитирует работу платформы Уровня 1\nicefrac{1}{2} (PC-совместимый компьютер без операционной системы).  Это позволяет одновременно запустить несколько разных платформ Уровня 2 (\emph{гостевых операционных систем}) на одной машине.

Причины, по которым разработчики платформ используют эти нарушения иерархии, отличаются большим разнообразием.  Например, это могут быть соображения удобства отладки и тестирования, или желание обеспечить совместимость со старыми платформами, или желание запустить несколько платформ на одной машине.

Программная эмуляция и виртуализация низкоуровневых платформ -- это очень интересная тема, но она увела бы нас далеко в сторону от темы книги. 

\section{Каждая платформа имеет язык}

Платформы отличаются не только наборами ресурсов, которые они предоставляют, но также и средствами, используемыми для описания задач, которые мы хотели бы решить при помощи платформы.  Иными словами, каждая платформа имеет собственный \emph{язык}.

Понятие языка вычислительных платформ несколько отличается от обыденного значения слова "язык".  В вычислительной технике, (формальный) язык определяется как набор правил сочетания символов.  Сочетания, соответствующие этим правилам, формируют валидные предложения.  Вместе, набор символов (\emph{алфавит}) и правил (\emph{синтаксис}) определяют язык и называются его \emph{грамматикой}.   Последовательность символов, которая не подчиняется правилам языка,  \emph{не является предложением} и называется \emph{недопустимой} или \emph{синтаксически некорректной}.

\subsection{Программируемая платформа имеет язык программирования}

Нам гврвнтируется, что платформа "поймет" все валидные предложения, написанные на ее языке.  Если платформа \emph{программируемая} (как Платформа 3\nicefrac{1}{2} CdM-8), ее язык называется \emph{языком программирования}\footnote{Платформа может иметь управляющий язык, который не является языком программирования.  Точное определение того, какие синтаксические и семантические средства необходимы, чтобы язык считался языком программирования, выходит за пределы темы этой книги. Следует также отметить, что граница между языками программирования и "просто" языками управления не всегда строго определена. Так, язык \LaTeX, на котором написана эта книга, обычно используют и рассматривают как "просто" язык разметки текста.  Но он имеет достаточно мощные средства описания последовательностей действий, чтобы на нем можно было написать бесконечный цикл или саморазмножающуюся программу (\emph{вирус}).}, а валидные предложения называются \emph{программами}.  Последовательность символов, которая не формирует валидного предложения  \emph{не является программой} и не может быть "понята" платформой.  Однако, это только часть истории, потому что грамматические правила не говорят нам, \emph{что платформа будет делать} при попытке исполнить программу (что эта программа \emph{означает}).

Существует еще один набор правил и описаний, предназначенный для того, чтобы присвоить смысл программам.  Смысл программы называется ее  \emph{семантикой}.  Программа может быть синтаксически корректной (и этого достаточно, чтобы она могла быть исполнена), но некорректной семантически (делать не то, что мы хотели).  В этом случае говорят, что программа содержит \emph{семантические ошибки} или "баги" (в русском языке, слово "ошибка" без уточнений можетозначать как синтаксическую, так и семантическую некорректность).

Замечание: Любая работающая программа, предоставляющая ресурсы, которые могут быть использованы для решения проблемы, сама по себе является платформой.  Однако, вовсе не обязательно такая платформа является программируемой.  Например, простой текстовый редактор (такой, как Windows notepad) -- это платформа для создания и редактирования текстовых файлов, теоретически пригодная и для написания текстов на языках программирования.  Но эта платформа не имеет  собственного языка программирования.  Более сложные редакторы, такие, как  vim или Notepad++ -- это программируемые платформы.  Они имеют \emph{скриптовые языки} или \emph{языки сценариев}, при помощи которых можно механизировать сложные или повторяющиеся действия, например, реализовать синтаксическую подсветку или "красивое" форматирование программ на языке С.  В соответствии с классификацией Таненбаума, сам текстовый редактор является платформой Уровня 5.  Исполняющиеся в нем скрипты, очевидно, следует считать платформой Уровня 6 или выше.

\subsection{"Язык" электронных схем?}

В аппаратном обеспечении, мы используем электронные схемы для создания машин, которые нужны нам для решения задач.  Хотя это и может прозвучать странно, но может быть полезно думать о деталях схем как о символах "языка схем", и об ограничениях на их соединения как о "синтаксических правилах".  Вместе они играют роль грамматики.  Дизайн аппаратного устройства -- это обычно диаграмма, показывающая различные компоненты и то, как они соединены друг с другом.  Настоящая машина получается путем создания устройства, которое соответствует дизайну.

В отличие от платформ более высоких уровней, вы можете создать "синтаксически некорректную" электронную схему, и никто вам не сообщит о синтаксической ошибке.  Но при попытке включить такую схему она может физически разрушиться, "сгореть".  Чаще всего слово "сгореть" обозначает, что какой-то компонент перегрелся и перестал работать.  Но при использовании достаточно мощных блоков питания и сочетании некоторых других обстоятельств, вы можете увидеть и горение в буквальном смысле, с дымом, искрами и даже открытым пламенем.

Устройство, которое подчиняется правилам (и, таким образом, "синтаксически корректно") будет "работать", в том смысле, что оно выполнит какое-то действие или даже несколько действий и не разрушится при этом.  Но сами по себе правила соединения компонентов не говорят нам, каковы будут эти действия.  Поведение каждого компонента под воздействием различных сигналов и правила, которые описывают коллективное поведение, могут пониматься как "семантика" электронной схемы.  Так же, как и с программным обеспечением, можно спроектировать и построить устройство, которое \emph{синтаксически корректно} (будет выполнять некоторые действия), но \emph{некорректно семантически} (это будут \emph{неправильные} действия).  Устройство такого рода считается содержащим "баги", так же, как и семантически некорректная программа.

\section{Все платформы вычисляют}

Несмотря на множество различий, есть одна общая вещь между всеми описаниями, имеющими оношение к определению платфомры: все они определяют
вычислительную среду определенного  \emph{уровня абстракции}.  Высокие уровни включают артефакты из сферы обработки информации: файлы, базы данных, объекты мультимедиа и так далее.  Нижние уровни включают обитателей мира сигналов: шины, защелки, вентили, регистры и т.д.

Действия платформы соответствуют ее уровню: в то врмя, как платформа Уровня 2 может слать сигналы другим устройствам, изменять состояние регистров или писать в определенные места памяти, платформа Уровня 5 может предоставлять инструкции, которые показывают веб-страницу или выполняют запрос к базе данных.  Высокоуровневые инструкции такого рода переводятся во множество инструкций более низкого уровня и эти переводы могут проходить через несколько уровней абстракции, прежде чем достигнут самого низкого уровня и превратятся в последовательности из миллионов очень простых инструкций и будут исполнены.

\subsection{ Аппаратура, программы и виртуальные машины}

Возвращаясь к диаграмме Таненбаума, мы видим, что вертикальные линии представляют собой поддержку, которая предоставляется для платформ вверху иерархии платформам нижних уровней. Эти механизмы поддержки позволяют нам создавать высокоуровневые платформы, которые предоставляют одношаговые действия, которые могли бы быть достигнуты на низком уровне лишь путем выдачи множества команд и использования множества различных ресурсов.  Высокоуровневые платформы считаются более \emph{абстрактными}, в том смысле, что их пользователям и даже разработчикам не нужно [постоянно] заботиться обо всех деталях того, как каждый кусочек работы будет исполнен машиной.

Когда платформа создается работающей программой, мы говорим что это \emph{Виртуальная Машина} (ВМ), и мы называем процесс создания такой платформы \emph{виртуализацией}. Мы имеем в виду, что более высокоуровневая платформа создает \emph{иллюзию} "реальной" машины, которая предоставляет средства и ресурсы, существенно более сложные (но, как правило, более простые в использовании) чем предоставляемые низкоуровневой платформой, на которой она построена.  Мы называем платформу виртуальной машиной чтобы отметить, что она реализована программно, а не аппаратно.

Теоретически возможно построить платформу любого уровня сложности прямо из аппаратных компонентов, так что программное обеспечение не будет играть никакой роли в ее реализации.  Например, можно себе представить текстовый процессор, построенный на последовательных логических вентилях.  Это будет "реальный" текстовый процессор.  Однако, такая машина будет иметь невероятно сложное внутреннее устройство, что сделает ее разработку и изготовление очень дорогими.  И для любой ее модификации (в том числе и для исправления неизбежных в таком сложном устройстве "багов") необходимо будет заменять аппаратные компоненты, что также дорого.  И такая машина будет пригодна только для одной задачи, так что нам могла бы потребоваться другая машина для получения и отправки электронной почты.

Оказалось, что намного лучше построить широко применимую программируемую аппаратную платформу и написать программу, которая заставляет ее вести себя так, как если бы она была текстовым процессором. Мы получим "виртуальный" текстовый процессор, который делает то же самое, что и "реальный", но за небольшую долю его стоимости.  Пока аппаратура предоставляет требуемый набор ресурсов и язык, поддерживающий все те команды, которые мы использовали, мы можем заменять оборудование без нарушения работы ВМ.  Мы также можем совершенствовать программу, реализующую ВМ, не сталкиваясь с необходимостью заменять оборудование.  Еще лучше, мы можем написать много разных программ для \emph{той же самой} аппаратной платформы, каждая из которых реализует собственную высокоуровневую платформу как ВМ, так что мы можем иметь "виртуальный" почтовый клиент, "виртуальный" пакет для презентаций, "виртуальный" веб-браузер и так далее.

\section{Перевод между уровнями Таненбаума}

ССуществуют три основных механизма для перевода сложных операций, предоставляемых высокоуровневой платформой, в более простые операции, предоставляемые платформами более низких уровней иерархии.

\subsection{Агрегация}

Агрегация - это единственный механизм, доступный для комбинации аппаратных компонентов.  Агрегация состоит в соединении компонентов так, чтобы получить агрегат, который, в свою очередь, может использоваться для решения конечной задачи или для построения чего-то более сложного.  Это обычная практика во всех видах инженерии и строительства.  Например, дом составляется из стен, дверей, окон, крыши и так далее. Все это агрегаты более простых компонентов, таких, как кирпичи или раствор.  Мы так привыкли к этой идеей, что часто думаем об агрегатах как о чем-то неделимом.  Например, мы рассматриваем батарейку AA как компонент фонарика, и редко думаем о компонентах, которые использовались для ее создания. Однако, если мы хотим производить батарейки, нам нужно будет найти правильные компоненты и соединить их правильным образом, чтобы получилась работающая батарейка
\footnote{Или эквивалент.  Пока агрегат из компонентов соответствует тем же спецификациям и выполняет те же функции, мы можем использовать его для замены батарейки АА, даже если он сделан из других компонетов или даже работает на других физических принципах.  Мы можем заменить батарейку АА аккумулятором или даже топливным элементом, лишь бы он имел те же габариты и выдавал то же напряжение.}.

В вычислительном оборудовании, транзисторы агрегируются в микросхемы, микросхемы затем могут агрегироваться в платы, а платы объединяются чтобы сформировать платформу, способную исполнять программное обеспечение.  Когда нам нужна микросхема, реализующая известный набор функций, мы часто можем просто взять ее с полки, не заботясь о том, как именно она была изготовлена.

Важно понимать, что агрегация \emph{экстенсивна}.  Она заключается в добавлении компонентов каждый раз, когда нам требуется агрегат.  Если стена -- это композит из 1000 кирпичей, нам необходима 1000 кирпичей для ее постройки, и другая 1000 кирпичей, если мы хотим построить другую стену.  Не получится построить одну стену и заставить дом использовать эту стену четыре раза.

Аналогично, если мы хотим 16Gb ОЗУ в компьютере, а есть только 8Gb, то нам придется поставить вдвое больше микросхем памяти, так что они в совокупности будут содержать вдвое больше транзисторов, потреблять вдвое больше мощности и стоить в два раза дороже.

Агрегация также доступна как механизм для комбинирования программных компонентов.  В действительности, любая программа представляет собой композит из множества инструкций.  Известно два основных способа агрегации программ.  Первый -- это вызов подпрограмм.  Подпрограммы в той или иной форме есть во всех современных языках программирования. Поэтому мы рассчитываем, что читатель знаком с этой концепцией, и не будем подробно останавливаться на ней здесь, хотя эта концепция глубока и интересна, и мы к ней еще вернемся.  Впрочем, здесь можно было бы отметить, что вызов подпрограмм можно уподобить постройке дома путем постройки одной стены и использования этой стены четыре раза.

Другой способ -- это так называемые макроопределения, макрокоманды или просто макро.  Макроопределение, как и подпрограмма -- это некоторый заранее определенный набор команд, который потом можно использовать, как если бы это была просто команда.  В некоторых языках, например, в С, вызов макроопределения внешне неотличим от вызова подпрограммы.  Но при обращении к макро происходит просто подстановка команд из определения в то место, где был сделан вызов.  Если программное макро вызывается пять раз, соответствующий набор инструкций также будет продублирован пять раз, поэтому команды из макроопределений ведут себя так же, как кирпичи для строительства стен или компоненты для узлов аппаратуры.  Макроопределения широко используются при программировании на языке ассемблера, и в ходе изучения Платформы 3\nicefrac{1}{1} мы поймем некоторые из причин, по которым они могут иногда быть удобнее, чем вызовы подпрограмм.


\subsection{?????????????}

????????????? -- ??? ?????? ???????????? ???????? ?????????? ??? ?? ?????????? ????? ???????????? ? ??????????? ????????????, ??? ? ????? ???????? ???????????? ???????????.   ????????????? ??????? ? ???, ??? ?????? ????????? ??????? ????????? ???????? ?????? ????????????? ?????????? ??????? ????, ??????? ????? ???????? ?????????? ????? ????? ??????, ????????? ??, ? ????????? ? ??????? ? ?????????? ????????? ??????????.  

?????????? ?????? ?????? ??? ???? ?????????? ?????????? ??????????? ?????????????? ????????? ???????.  ??????????, ??? ?????? ? ???????????? ? ???????????? ? ???????? ?????????, ??????? ?????????? \emph{???????????????}.  ???, ?????????? ????????? ?????????????? ????????? ?? ???????? ?????, ? ???-??????? ?????????????? HTML-????????, ??????? ???????? ?? ??????? ?????? ?? ??????? ? ??????????? ? ??????? ????????????? ???-???????? ?? ???? ?????????.  

????????????? ? ?????? ???? -- ????? ?? ???????????? ????????, ??? ? ????????????????: ?????? ???, ????? ????????????? ????????? ???? ? ?? ?? ???????, ?? ????????? ???? ? ?? ?? ?????????????????? ???????? ?? ?? ??????? ?, ??????????, ??????????.  ???? ????????? ?????? 2 CdM-8 -- ?????? ????? ??????? ?????????????.  ??? ?????????? ????? ? ??? ?? ???????, ??? ?????? ?????????? ???? ? ??? ?? ????? ???????? ? ????? ? ??? ?? ??????????????????.

?????????? ????? ??????? ??????????????, ??????? ?????????? ????????? ?????????? ????? ??? ????? ???????????? ????????????? ????????, ??????? ???????, ??? ???????? ???????.  ??? "???????????" ?? ????????? ?????????? ??????, ???????? ???????????? ?????????? ??? ????????? ????????? ?????????? ????????????, ????????? ????????????? ?????????? ? ??????????? ??????? ?????? (\emph{????}) ? ??..  ?????? ??? ???????? ??????????? ??????????? ??????????? ???????? ?????? 2 -- x86, ARM.  ?????????? ???? ?????????? ?? ???? ?????? ? ????? ????????? ??????? ?? ? ?? ????????????? ??????????, ??? ??????? ?? ?? ??????????? ??? ????????.
